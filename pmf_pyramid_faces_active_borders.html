<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>4-Body PMF Pyramid — Faces, Apex Links, Orbit</title>
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .app { display: grid; grid-template-columns: 300px 1fr 420px; grid-template-rows: auto 1fr auto; height: 100%; }
    header { grid-column: 1 / 4; padding: 10px 14px; border-bottom: 1px solid #ddd; }
    header h1 { margin: 0; font-size: 18px; }
    #left { border-right: 1px solid #eee; padding: 12px; overflow: auto; }
    #center { position: relative; background: #000; }
    #right { border-left: 1px solid #eee; padding: 12px; overflow: auto; }
    footer { grid-column: 1 / 4; border-top: 1px solid #ddd; padding: 8px 12px; display: flex; gap: 8px; align-items: center; }
    #canvas { width: 100%; height: 100%; min-height: 420px; display: block; }
    #faceLabel {
      position: absolute; top: 12px; left: 12px; background: rgba(255,255,255,0.92);
      padding: 6px 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; pointer-events: none;
    }
    .group { margin-bottom: 16px; }
    .group h3 { margin: 10px 0 6px; font-size: 14px; }
    .row { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin: 6px 0; }
    input[type="range"] { width: 140px; }
    select, input[type="number"] { width: 160px; }
    .measure { border: 1px solid #eee; padding: 10px; border-radius: 8px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; gap: 10px; cursor: pointer; }
    .measure .left { display: flex; flex-direction: column; }
    .status { display: inline-block; min-width: 72px; text-align: center; border-radius: 12px; padding: 4px 8px; font-size: 12px; color: #fff; }
    .value { margin-right:6px; min-width: 28px; display:inline-block; text-align:right; }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>4-Body PMF Pyramid — Face Colors, Active Borders, Apex Links, Orbit</h1>
      <div>Drag to orbit. Click any measure label on the right to orbit the camera to that face. Faces are color-coded; the active face has bold white borders.</div>
    </header>

    <!-- Left Controls -->
    <aside id="left">
      <div class="group"><h3>Product</h3>
        <div class="row"><label>Features</label><input id="features" type="range" min="0" max="5" value="3"></div>
        <div class="row"><label>Quality</label><input id="quality" type="range" min="0" max="5" value="3"></div>
        <div class="row"><label>UX/Onboarding</label><input id="ux" type="range" min="0" max="5" value="3"></div>
        <div class="row"><label>Cost Index</label><input id="cost" type="range" min="0" max="5" value="2"></div>
      </div>
      <div class="group"><h3>Price</h3>
        <div class="row"><label>Price Point</label><input id="price" type="number" value="20"></div>
        <div class="row"><label>Discount %</label><input id="discount" type="range" min="0" max="100" value="0"></div>
      </div>
      <div class="group"><h3>Promotion</h3>
        <div class="row"><label>Messaging</label><input id="messaging" type="range" min="0" max="5" value="3"></div>
        <div class="row"><label>Brand</label><input id="brand" type="range" min="0" max="5" value="3"></div>
      </div>
      <div class="group"><h3>Placement</h3>
        <div class="row"><label>Geo Coverage</label><input id="geo" type="range" min="0" max="5" value="2"></div>
        <div class="row"><label>Go-to-Market</label><input id="gtm" type="range" min="0" max="5" value="2"></div>
      </div>
    </aside>

    <!-- Center Pyramid -->
    <main id="center">
      <div id="faceLabel">Face: —</div>
      <canvas id="canvas"></canvas>
    </main>

    <!-- Right Measures -->
    <aside id="right">
      <div class="group"><h3>Base Edge Measures (click label to focus)</h3>
        <div class="measure" data-face="adoption">
          <div class="left"><strong>Adoption</strong><small>(Product–Promotion)</small></div>
          <div>
            <span id="adoption" class="value">0.0</span>
            <span id="adoptionStatus" class="status">-</span>
          </div>
        </div>

        <div class="measure" data-face="wtp">
          <div class="left"><strong>WTP / Churn</strong><small>(Promotion–Price)</small></div>
          <div>
            <span id="wtp" class="value">0.0</span>
            <span id="wtpStatus" class="status">-</span>
          </div>
        </div>

        <div class="measure" data-face="channelPricing">
          <div class="left"><strong>Channel Pricing</strong><small>(Price–Placement)</small></div>
          <div>
            <span id="channelPricing" class="value">0.0</span>
            <span id="channelPricingStatus" class="status">-</span>
          </div>
        </div>

        <div class="measure" data-face="activation">
          <div class="left"><strong>Activation & Retention</strong><small>(Placement–Product)</small></div>
          <div>
            <span id="activation" class="value">0.0</span>
            <span id="activationStatus" class="status">-</span>
          </div>
        </div>

        <div class="measure" data-face="grossMargin">
          <div class="left"><strong>Gross Margin / Unit Economics</strong><small>(Product–Price)</small></div>
          <div>
            <span id="grossMargin" class="value">0.0</span>
            <span id="grossMarginStatus" class="status">-</span>
          </div>
        </div>

        <div class="measure" data-face="channelFit">
          <div class="left"><strong>Channel Fit</strong><small>(Promotion–Placement)</small></div>
          <div>
            <span id="channelFit" class="value">0.0</span>
            <span id="channelFitStatus" class="status">-</span>
          </div>
        </div>
      </div>

      <div class="group"><h3>Apex Links</h3>
        <div class="measure">
          <div class="left"><strong>Loves Product</strong><small>(Customer↔Product)</small></div>
          <div>
            <span id="lovesProduct" class="value">0.0</span>
            <span id="lovesProductStatus" class="status">-</span>
          </div>
        </div>
        <div class="measure">
          <div class="left"><strong>Has Budget</strong><small>(Customer↔Price)</small></div>
          <div>
            <span id="hasBudget" class="value">0.0</span>
            <span id="hasBudgetStatus" class="status">-</span>
          </div>
        </div>
        <div class="measure">
          <div class="left"><strong>Uses Channel</strong><small>(Customer↔Placement)</small></div>
          <div>
            <span id="usesChannel" class="value">0.0</span>
            <span id="usesChannelStatus" class="status">-</span>
          </div>
        </div>
        <div class="measure">
          <div class="left"><strong>Customers Tell Your Story</strong><small>(Customer↔Promotion)</small></div>
          <div>
            <span id="tellStory" class="value">0.0</span>
            <span id="tellStoryStatus" class="status">-</span>
          </div>
        </div>
      </div>
    </aside>

    <footer>
      <button id="save">Save</button>
      <button id="load">Load</button>
      <button id="auto">Auto-Simulate</button>
    </footer>
  </div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
  <script>
    let scene, camera, renderer, mesh, highlightGroup;
    const canvas = document.getElementById('canvas');
    const faceLabel = document.getElementById('faceLabel');

    let baseVerts = []; // v0..v3
    let apexVert = null;

    const controls = {
      features: 3, quality: 3, ux: 3, cost: 2,
      price: 20, discount: 0,
      messaging: 3, brand: 3,
      geo: 2, gtm: 2
    };

    const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));

    function statusColor(val) {
      if (val >= 4) return { text: "Green", color: "#4caf50" };
      if (val >= 2) return { text: "Yellow", color: "#ffb300" };
      return { text: "Red", color: "#e53935" };
    }

    // ---------------------- Measures ----------------------
    function updateMeasures() {
      // Base edge measures
      const adoption = (controls.features + controls.quality + controls.messaging + controls.brand)/4;
      const wtp = (controls.price/10 + (100-controls.discount)/25 + controls.messaging + controls.brand)/4;
      const channelPricing = (controls.price/10 + controls.discount/25 + controls.geo + controls.gtm)/4;
      const activation = (controls.geo + controls.gtm + controls.features + controls.ux)/4;
      const grossMargin = (5 - controls.cost) + controls.price/20;
      const channelFit = (controls.messaging + controls.brand + controls.geo)/3;

      // Apex links (two new ones included)
      const lovesProduct = (controls.features + controls.quality + controls.ux)/3;
      const hasBudget = (controls.price/20 + (100-controls.discount)/25);
      const usesChannel = (controls.geo + controls.gtm)/2;         // Customer↔Placement
      const tellStory = (controls.messaging + controls.brand)/2;    // Customer↔Promotion

      const measures = {
        adoption: clamp(adoption,0,5),
        wtp: clamp(wtp,0,5),
        channelPricing: clamp(channelPricing,0,5),
        activation: clamp(activation,0,5),
        grossMargin: clamp(grossMargin,0,5),
        channelFit: clamp(channelFit,0,5),
        lovesProduct: clamp(lovesProduct,0,5),
        hasBudget: clamp(hasBudget,0,5),
        usesChannel: clamp(usesChannel,0,5),
        tellStory: clamp(tellStory,0,5)
      };

      // UI values + color badges
      const list = [
        ["adoption","adoptionStatus"],
        ["wtp","wtpStatus"],
        ["channelPricing","channelPricingStatus"],
        ["activation","activationStatus"],
        ["grossMargin","grossMarginStatus"],
        ["channelFit","channelFitStatus"],
        ["lovesProduct","lovesProductStatus"],
        ["hasBudget","hasBudgetStatus"],
        ["usesChannel","usesChannelStatus"],
        ["tellStory","tellStoryStatus"]
      ];
      list.forEach(([id,sid])=>{
        const val = measures[id];
        const el = document.getElementById(id);
        if (el) el.textContent = (val??0).toFixed(1);
        const st = document.getElementById(sid);
        if (st) {
          const sc = statusColor(val);
          st.textContent = sc.text;
          st.style.background = sc.color;
          st.style.color = "#fff";
        }
      });

      return measures;
    }

    // ---------------------- Geometry ----------------------
    function computeBaseVerts(measures) {
      // Assign each base corner to one body:
      // v0 Product, v1 Promotion, v2 Price, v3 Placement
      const sProduct   = (measures.adoption + measures.activation + measures.grossMargin)/3;           // v0
      const sPromotion = (measures.adoption + measures.wtp + measures.channelFit)/3;                   // v1
      const sPrice     = (measures.wtp + measures.channelPricing + measures.grossMargin)/3;            // v2
      const sPlacement = (measures.channelPricing + measures.activation + measures.channelFit)/3;      // v3

      const r = m => 1.0 + (m/5)*1.6; // radius 1..2.6
      const r0=r(sProduct), r1=r(sPromotion), r2=r(sPrice), r3=r(sPlacement);

      // Place corners at 45°, 135°, 225°, 315°
      const a0 = Math.PI/4, a1 = 3*Math.PI/4, a2 = 5*Math.PI/4, a3 = 7*Math.PI/4;
      const v0 = new THREE.Vector3( Math.cos(a0)*r0, 0, Math.sin(a0)*r0 ); // Product
      const v1 = new THREE.Vector3( Math.cos(a1)*r1, 0, Math.sin(a1)*r1 ); // Promotion
      const v2 = new THREE.Vector3( Math.cos(a2)*r2, 0, Math.sin(a2)*r2 ); // Price
      const v3 = new THREE.Vector3( Math.cos(a3)*r3, 0, Math.sin(a3)*r3 ); // Placement

      // Apex height includes ALL four apex links (two new ones)
      const apexSum = measures.lovesProduct + measures.hasBudget + measures.usesChannel + measures.tellStory; // 0..20
      const h = 1.5 + (apexSum/20)*3.5; // 1.5 .. 5.0
      const v4 = new THREE.Vector3(0, h, 0);

      baseVerts = [v0,v1,v2,v3];
      apexVert = v4;
      return {v0,v1,v2,v3,v4};
    }

    function materialsForFaces(measures) {
      const col = k => statusColor(measures[k]).color;
      // Order must match faces tri grouping (see createPyramidMesh)
      return [
        new THREE.MeshPhongMaterial({ color: col('adoption'),        shininess: 40, flatShading: true, opacity: 0.9, transparent: true, side: THREE.DoubleSide }), // face 0
        new THREE.MeshPhongMaterial({ color: col('wtp'),             shininess: 40, flatShading: true, opacity: 0.9, transparent: true, side: THREE.DoubleSide }), // face 1
        new THREE.MeshPhongMaterial({ color: col('channelPricing'),  shininess: 40, flatShading: true, opacity: 0.9, transparent: true, side: THREE.DoubleSide }), // face 2
        new THREE.MeshPhongMaterial({ color: col('activation'),      shininess: 40, flatShading: true, opacity: 0.9, transparent: true, side: THREE.DoubleSide }), // face 3
        new THREE.MeshPhongMaterial({ color: "#bbbbbb",              shininess: 20, flatShading: true, opacity: 0.6, transparent: true, side: THREE.DoubleSide }), // base tri A
        new THREE.MeshPhongMaterial({ color: "#bbbbbb",              shininess: 20, flatShading: true, opacity: 0.6, transparent: true, side: THREE.DoubleSide })  // base tri B
      ];
    }

    function createPyramidMesh(verts, measures) {
      const {v0,v1,v2,v3,v4} = verts;
      const positions = new Float32Array([
        // SIDE FACES — order matters (face indices 0..3)
        v0.x,v0.y,v0.z,  v1.x,v1.y,v1.z,  v4.x,v4.y,v4.z,  // face 0: Adoption (Product–Promotion)
        v1.x,v1.y,v1.z,  v2.x,v2.y,v2.z,  v4.x,v4.y,v4.z,  // face 1: WTP/Churn (Promotion–Price)
        v2.x,v2.y,v2.z,  v3.x,v3.y,v3.z,  v4.x,v4.y,v4.z,  // face 2: Channel Pricing (Price–Placement)
        v3.x,v3.y,v3.z,  v0.x,v0.y,v0.z,  v4.x,v4.y,v4.z,  // face 3: Activation (Placement–Product)
        // BASE (kept neutral)
        v0.x,v0.y,v0.z,  v1.x,v1.y,v1.z,  v2.x,v2.y,v2.z,  // base A
        v2.x,v2.y,v2.z,  v3.x,v3.y,v3.z,  v0.x,v0.y,v0.z   // base B
      ]);
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions,3));
      geometry.clearGroups();
      for (let g=0; g<6; g++) geometry.addGroup(g*3, 3, g); // 4 faces + 2 base tris
      geometry.computeVertexNormals();

      const mats = materialsForFaces(measures);
      return new THREE.Mesh(geometry, mats);
    }

    // ---------------------- Active Face Highlight ----------------------
    let highlightGroup = null;
    function drawActiveFaceBorders(faceIdx) {
      if (highlightGroup) { scene.remove(highlightGroup); highlightGroup = null; }
      if (faceIdx == null || faceIdx < 0 || faceIdx > 3) return;

      const edgesByFace = [
        [[0,1],[1,4],[4,0]], // face 0: adoption
        [[1,2],[2,4],[4,1]], // face 1: wtp
        [[2,3],[3,4],[4,2]], // face 2: channelPricing
        [[3,0],[0,4],[4,3]], // face 3: activation
      ];
      const idxPairs = edgesByFace[faceIdx];
      const verts = [...baseVerts, apexVert]; // indices 0..4

      const g = new THREE.Group();
      const radius = 0.05; // thickness
      const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, depthTest: false }); // always on top
      idxPairs.forEach(p => {
        const a = verts[p[0]], b = verts[p[1]];
        const dir = new THREE.Vector3().subVectors(b,a);
        const len = dir.length();
        const mid = new THREE.Vector3().addVectors(a,b).multiplyScalar(0.5);
        const cyl = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, len, 12), mat);
        cyl.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir.clone().normalize());
        cyl.position.copy(mid);
        cyl.renderOrder = 999;
        g.add(cyl);
      });
      highlightGroup = g;
      scene.add(highlightGroup);
    }

    // ---------------------- Scene Update ----------------------
    function updateScene() {
      const measures = updateMeasures();
      const verts = computeBaseVerts(measures);
      if (mesh) scene.remove(mesh);
      mesh = createPyramidMesh(verts, measures);
      scene.add(mesh);
      activeFaceLast = -1; // force re-evaluate highlight on next frame
    }

    // ---------------------- Camera Orbit ----------------------
    let camAnim = null;

    function faceNormalForKey(key) {
      // v0 Product, v1 Promotion, v2 Price, v3 Placement; apex v4
      let a, b, c;
      switch (key) {
        case "adoption":       a=baseVerts[0]; b=baseVerts[1]; c=apexVert; break; // v0-v1-v4
        case "wtp":            a=baseVerts[1]; b=baseVerts[2]; c=apexVert; break; // v1-v2-v4
        case "channelPricing": a=baseVerts[2]; b=baseVerts[3]; c=apexVert; break; // v2-v3-v4
        case "activation":     a=baseVerts[3]; b=baseVerts[0]; c=apexVert; break; // v3-v0-v4
        default:               a=baseVerts[0]; b=baseVerts[1]; c=apexVert;
      }
      // Outward normal: (b-a) x (c-a)
      return new THREE.Vector3().crossVectors(
        new THREE.Vector3().subVectors(b,a),
        new THREE.Vector3().subVectors(c,a)
      ).normalize();
    }

    function orbitToFace(key) {
      if (!baseVerts.length) return;
      const n = faceNormalForKey(key);
      // Keep camera height, rotate around Y toward normal direction
      const dir = new THREE.Vector3(n.x, 0, n.z).normalize();
      if (dir.length() < 1e-4) dir.set(1,0,0);
      const radius = camera.position.length();
      const targetPos = new THREE.Vector3(dir.x*radius, camera.position.y, dir.z*radius);
      camAnim = { from: camera.position.clone(), to: targetPos, start: performance.now(), dur: 650 };
    }

    function animateCam() {
      if (!camAnim) return;
      const t = (performance.now() - camAnim.start) / camAnim.dur;
      if (t >= 1) { camera.position.copy(camAnim.to); camAnim = null; }
      else {
        const ease = t<0.5 ? 2*t*t : -1+(4-2*t)*t; // easeInOutQuad
        camera.position.lerpVectors(camAnim.from, camAnim.to, ease);
      }
      camera.lookAt(0,0,0);
    }

    // ---------------------- Active Face Label + Highlight ----------------------
    let activeFaceLast = -1;
    function updateFaceLabelAndHighlight() {
      if (!mesh) return;
      const pos = mesh.geometry.attributes.position;
      const faces = [
        { tri:[0,1,2],   name:"Adoption" },
        { tri:[3,4,5],   name:"WTP / Churn" },
        { tri:[6,7,8],   name:"Channel Pricing" },
        { tri:[9,10,11], name:"Activation & Retention" },
      ];
      let best = -Infinity, idx = -1, label="—";
      const camDir = new THREE.Vector3().subVectors(camera.position, new THREE.Vector3(0,0,0)).normalize();
      for (let i=0;i<faces.length;i++) {
        const f = faces[i];
        const a = new THREE.Vector3(pos.getX(f.tri[0]), pos.getY(f.tri[0]), pos.getZ(f.tri[0]));
        const b = new THREE.Vector3(pos.getX(f.tri[1]), pos.getY(f.tri[1]), pos.getZ(f.tri[1]));
        const c = new THREE.Vector3(pos.getX(f.tri[2]), pos.getY(f.tri[2]), pos.getZ(f.tri[2]));
        const n = new THREE.Vector3().crossVectors(
          new THREE.Vector3().subVectors(b,a),
          new THREE.Vector3().subVectors(c,a)
        ).normalize();
        const d = n.dot(camDir); // outward normal facing camera => large positive
        if (d > best) { best = d; idx = i; label = f.name; }
      }
      faceLabel.textContent = "Face: " + label;
      if (idx !== activeFaceLast) {
        activeFaceLast = idx;
        drawActiveFaceBorders(idx);
      }
    }

    // ---------------------- Three.js Init ----------------------
    function initThree() {
      scene = new THREE.Scene();
      const w = canvas.clientWidth, h = canvas.clientHeight;
      camera = new THREE.PerspectiveCamera(45, w/h, 0.1, 100);
      camera.position.set(6, 5, 6);
      camera.lookAt(0,0,0);

      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(w,h);
      window.addEventListener('resize', onResize);

      scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));
      const dir = new THREE.DirectionalLight(0xffffff, 0.9);
      dir.position.set(4, 6, 3);
      scene.add(dir);

      updateScene();
      animate();

      // Drag orbit (camera around Y with slight vertical)
      let dragging=false, prev={x:0,y:0};
      canvas.addEventListener('mousedown', e=>{dragging=true; prev={x:e.clientX, y:e.clientY};});
      window.addEventListener('mouseup', ()=>dragging=false);
      window.addEventListener('mousemove', e=>{
        if (!dragging) return;
        const dx=(e.clientX-prev.x)/200, dy=(e.clientY-prev.y)/200;
        prev={x:e.clientX, y:e.clientY};
        const radius = camera.position.length();
        const angle = Math.atan2(camera.position.z, camera.position.x);
        const newAngle = angle - dx;
        const y = clamp(camera.position.y - dy*2, 1, 12);
        camera.position.set(Math.cos(newAngle)*radius, y, Math.sin(newAngle)*radius);
        camera.lookAt(0,0,0);
      });
    }

    function onResize() {
      const w = canvas.clientWidth, h = canvas.clientHeight;
      renderer.setSize(w,h);
      camera.aspect = w/h;
      camera.updateProjectionMatrix();
    }

    function animate() {
      requestAnimationFrame(animate);
      animateCam();
      renderer.render(scene, camera);
      updateFaceLabelAndHighlight();
    }

    // ---------------------- UI Wiring ----------------------
    function attachControls() {
      const ids = ["features","quality","ux","cost","price","discount","messaging","brand","geo","gtm"];
      ids.forEach(id => {
        const el = document.getElementById(id);
        el.addEventListener('input', () => {
          const val = (el.type === "number") ? parseFloat(el.value||"0") : +el.value;
          controls[id] = isNaN(val) ? 0 : val;
          updateScene();
        });
      });

      // Clickable measure rows (orbit to face)
      document.querySelectorAll(".measure[data-face]").forEach(row => {
        row.addEventListener('click', () => {
          const key = row.getAttribute('data-face');
          orbitToFace(key);
        });
      });
    }

    // Save/Load
    function attachSaveLoad() {
      const saveBtn = document.getElementById('save');
      const loadBtn = document.getElementById('load');
      if (saveBtn) saveBtn.addEventListener('click', ()=>{
        localStorage.setItem('pmf_controls', JSON.stringify(controls));
        alert('Saved.');
      });
      if (loadBtn) loadBtn.addEventListener('click', ()=>{
        const data = localStorage.getItem('pmf_controls');
        if (!data) return alert('No saved scenario.');
        const obj = JSON.parse(data);
        Object.assign(controls, obj);
        Object.keys(controls).forEach(k=>{
          const el = document.getElementById(k);
          if (el) el.value = String(controls[k]);
        });
        updateScene();
      });
    }

    initThree();
    attachControls();
    attachSaveLoad();
  </script>
</body>
</html>