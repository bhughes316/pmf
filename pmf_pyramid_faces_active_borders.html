<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>4-Body PMF Pyramid – Fixed Orbit, Dynamic Sizing</title>
<style>
  html, body { margin: 0; height: 100%; font-family: sans-serif; overflow: hidden; }
  .app {
    display: grid;
    grid-template-columns: 260px minmax(400px, 1fr) 320px;
    grid-template-rows: auto 1fr auto;
    height: 100vh;
  }
  header { grid-column: 1 / 4; padding: 8px; border-bottom: 1px solid #ccc; }
  #left, #right { overflow-y: auto; padding: 10px; }
  #left { border-right: 1px solid #eee; }
  #right { border-left: 1px solid #eee; }
  #center {
    position: relative;
    background: #000;
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: 400px;
    overflow: hidden;
  }
  #canvas { width: 100%; height: 100%; max-height: 80vh; display: block; }
  #faceLabel {
    position: absolute; top: 10px; left: 10px;
    background: rgba(255,255,255,0.9); padding: 4px 8px; border-radius: 4px;
    font-size: 13px;
  }
  footer { grid-column: 1 / 4; border-top: 1px solid #ccc; padding: 4px 8px; }
  .measure { cursor: pointer; margin: 6px 0; padding: 4px; border: 1px solid #eee; border-radius: 4px; }
  .status { display: inline-block; min-width: 70px; text-align: center; padding: 2px 6px; border-radius: 10px; color: #fff; font-size: 12px; }
</style>
</head>
<body>
  <div class="app">
    <header><h2>4-Body PMF Pyramid – Fixed Orbit & Dynamic Sizing</h2></header>
    <aside id="left">
      <h3>Controls</h3>
      <label>Features <input type="range" id="features" min="0" max="5" value="3"></label><br>
      <label>Quality <input type="range" id="quality" min="0" max="5" value="3"></label><br>
      <label>UX <input type="range" id="ux" min="0" max="5" value="3"></label><br>
      <label>Cost <input type="range" id="cost" min="0" max="5" value="2"></label><br>
      <label>Price <input type="number" id="price" value="20"></label><br>
      <label>Discount % <input type="range" id="discount" min="0" max="100" value="0"></label><br>
      <label>Messaging <input type="range" id="messaging" min="0" max="5" value="3"></label><br>
      <label>Brand <input type="range" id="brand" min="0" max="5" value="3"></label><br>
      <label>Geo <input type="range" id="geo" min="0" max="5" value="2"></label><br>
      <label>GTM <input type="range" id="gtm" min="0" max="5" value="2"></label>
    </aside>
    <main id="center">
      <canvas id="canvas"></canvas>
      <div id="faceLabel">Face: —</div>
    </main>
    <aside id="right">
      <h3>Indicators (Click to focus)</h3>
      <div class="measure" data-face="adoption">Adoption <span id="adoption" class="status">-</span></div>
      <div class="measure" data-face="wtp">WTP / Churn <span id="wtp" class="status">-</span></div>
      <div class="measure" data-face="channelPricing">Channel Pricing <span id="channelPricing" class="status">-</span></div>
      <div class="measure" data-face="activation">Activation <span id="activation" class="status">-</span></div>
      <div class="measure" data-face="grossMargin">Gross Margin <span id="grossMargin" class="status">-</span></div>
      <div class="measure" data-face="channelFit">Channel Fit <span id="channelFit" class="status">-</span></div>
      <h3>Apex Links</h3>
      <div class="measure">Loves Product <span id="lovesProduct" class="status">-</span></div>
      <div class="measure">Has Budget <span id="hasBudget" class="status">-</span></div>
      <div class="measure">Uses Channel <span id="usesChannel" class="status">-</span></div>
      <div class="measure">Customers Tell Your Story <span id="tellStory" class="status">-</span></div>
    </aside>
    <footer>Footer controls here</footer>
  </div>

<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
<script>
let scene, camera, renderer, mesh, borderGroup;
const center = document.getElementById("center");
const controls = {features:3,quality:3,ux:3,cost:2,price:20,discount:0,messaging:3,brand:3,geo:2,gtm:2};

// Status colors
function statusColor(v){if(v>=4)return"#4caf50";if(v>=2)return"#ffb300";return"#e53935";}

// Measures
function updateMeasures(){
  const m={};
  m.adoption=(controls.features+controls.quality+controls.messaging+controls.brand)/4;
  m.wtp=(controls.price/10+(100-controls.discount)/25+controls.messaging+controls.brand)/4;
  m.channelPricing=(controls.price/10+controls.discount/25+controls.geo+controls.gtm)/4;
  m.activation=(controls.geo+controls.gtm+controls.features+controls.ux)/4;
  m.grossMargin=(5-controls.cost)+controls.price/20;
  m.channelFit=(controls.messaging+controls.brand+controls.geo)/3;
  m.lovesProduct=(controls.features+controls.quality+controls.ux)/3;
  m.hasBudget=controls.price/20+(100-controls.discount)/25;
  m.usesChannel=(controls.geo+controls.gtm)/2;
  m.tellStory=(controls.messaging+controls.brand)/2;
  Object.entries(m).forEach(([k,v])=>{
    const el=document.getElementById(k); if(el){el.textContent=v.toFixed(1); el.style.background=statusColor(v);}
  });
  return m;
}

// Build pyramid
function buildPyramid(m){
  if(mesh) scene.remove(mesh);
  if(borderGroup) scene.remove(borderGroup);
  const v0=new THREE.Vector3(1,0,1),v1=new THREE.Vector3(-1,0,1),v2=new THREE.Vector3(-1,0,-1),v3=new THREE.Vector3(1,0,-1);
  const h=1.5+(m.lovesProduct+m.hasBudget+m.usesChannel+m.tellStory)/20*3.5;
  const v4=new THREE.Vector3(0,h,0);
  const geo=new THREE.BufferGeometry();
  const verts=[v0,v1,v4,v1,v2,v4,v2,v3,v4,v3,v0,v4,v0,v1,v2,v2,v3,v0];
  geo.setAttribute('position',new THREE.Float32BufferAttribute(verts.flatMap(v=>[v.x,v.y,v.z]),3));
  geo.computeVertexNormals();
  const mats=[
    new THREE.MeshPhongMaterial({color:statusColor(m.adoption)}),
    new THREE.MeshPhongMaterial({color:statusColor(m.wtp)}),
    new THREE.MeshPhongMaterial({color:statusColor(m.channelPricing)}),
    new THREE.MeshPhongMaterial({color:statusColor(m.activation)}),
    new THREE.MeshPhongMaterial({color:"#999",opacity:0.5,transparent:true}),
    new THREE.MeshPhongMaterial({color:"#999",opacity:0.5,transparent:true})
  ];
  for(let i=0;i<6;i++) geo.addGroup(i*3,3,i);
  mesh=new THREE.Mesh(geo,mats);
  scene.add(mesh);
  addBorders(v0,v1,v2,v3,v4);
}

// Borders
function addBorders(v0,v1,v2,v3,v4){
  borderGroup=new THREE.Group();
  const edges=[[v0,v1],[v1,v2],[v2,v3],[v3,v0],[v0,v4],[v1,v4],[v2,v4],[v3,v4]];
  const mat=new THREE.LineBasicMaterial({color:0xffffff});
  edges.forEach(([a,b])=>{
    const geo=new THREE.BufferGeometry().setFromPoints([a,b]);
    borderGroup.add(new THREE.Line(geo,mat));
  });
  scene.add(borderGroup);
}

// Init
function init(){
  scene=new THREE.Scene();
  camera=new THREE.PerspectiveCamera(45, center.clientWidth/center.clientHeight, 0.1, 100);
  camera.position.set(5,4,5);
  camera.lookAt(0,0,0);
  renderer=new THREE.WebGLRenderer({canvas:document.getElementById("canvas"),antialias:true});
  resizeCanvas();
  window.addEventListener("resize", resizeCanvas);

  scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1));
  const dl=new THREE.DirectionalLight(0xffffff,0.8);dl.position.set(5,10,7);scene.add(dl);

  document.querySelectorAll("#left input").forEach(inp=>{
    inp.addEventListener("input",()=>{controls[inp.id]=+inp.value;buildPyramid(updateMeasures());});
  });
  document.querySelectorAll(".measure[data-face]").forEach(m=>{
    m.addEventListener("click",()=>orbitToFace(m.dataset.face));
  });

  setupOrbitDrag();
  buildPyramid(updateMeasures());
  animate();
}

// Orbit Drag with fixed radius
let isDragging=false, prev={x:0,y:0}, spherical=new THREE.Spherical();
function setupOrbitDrag(){
  spherical.setFromVector3(camera.position.clone());
  center.addEventListener("mousedown",e=>{isDragging=true;prev.x=e.clientX;prev.y=e.clientY;});
  window.addEventListener("mouseup",()=>isDragging=false);
  window.addEventListener("mousemove",e=>{
    if(!isDragging)return;
    const dx=(e.clientX-prev.x)*0.005;
    const dy=(e.clientY-prev.y)*0.005;
    prev.x=e.clientX;prev.y=e.clientY;
    spherical.theta-=dx;
    spherical.phi=Math.max(0.1,Math.min(Math.PI-0.1,spherical.phi-dy));
    camera.position.setFromSpherical(spherical);
    camera.lookAt(0,0,0);
  });
}

// Resize Canvas
function resizeCanvas(){
  const w=center.clientWidth,h=center.clientHeight;
  renderer.setSize(w,h);
  camera.aspect=w/h;
  camera.updateProjectionMatrix();
}

// Orbit to face
let camAnim=null;
function orbitToFace(face){
  const dirs={adoption:[1,0,1],wtp:[-1,0,1],channelPricing:[-1,0,-1],activation:[1,0,-1]};
  const d=new THREE.Vector3(...dirs[face]);
  const r=camera.position.length(); d.normalize().multiplyScalar(r);
  camAnim={from:camera.position.clone(),to:d,start:performance.now(),dur:600};
}

function animate(){
  requestAnimationFrame(animate);
  if(camAnim){
    const t=(performance.now()-camAnim.start)/camAnim.dur;
    if(t>=1){camera.position.copy(camAnim.to);camAnim=null;}
    else{const e=t<0.5?2*t*t:-1+(4-2*t)*t;camera.position.lerpVectors(camAnim.from,camAnim.to,e);}
    camera.lookAt(0,0,0);
  }
  renderer.render(scene,camera);
}

init();
</script>
</body>
</html>
